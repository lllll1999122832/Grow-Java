# 1.  SEO

SEO（搜索引擎优化）是一种通过提升网站在搜索引擎中的自然排名，来增加网站流量和可见性的技术和策略。以下是对SEO的详细解释和优化方法：

### 什么是SEO？

SEO，即Search Engine Optimization，是指按照搜索引擎的算法，提升你的网站在搜索引擎中的自然排名。其目的是让网站在行业内占据领先地位，获得品牌收益，并吸引更多用户访问网站，提高网站的访问量和销售能力13。

### SEO的重要性

- **免费流量来源**：相较于付费广告，SEO能带来稳定的自然流量。
- **提升品牌知名度**：网站排名靠前有助于提升品牌知名度。
- **增加网站转换率**：吸引更多目标客群，提高产品或服务的销售量。
- **提升用户体验**：优化SEO的过程中，会注重网站的使用者体验4。

### 如何进行SEO优化？

1. **关键词选择**：

   - 选择与网站内容相关的关键词。
   - 首页部署品牌词和难度较大的通用词或产品词。
   - 内页布局更多关键词，每个内页推荐承载1-3个长尾关键词1。

2. **网站构架完善**：

   - 优化网站的URL结构，使其更易于搜索引擎抓取。
   - 做好站内各类页面之间的相关链接，建立反向链接1。

3. **网站内容策略**：

   - 丰富网站内容，提高内容质量。
   - 定期更新内容，确保内容的相关性和新鲜度1。

4. **页面和站外SEO优化**：

   - **On-Page SEO**：优化网页内容，包括标题标签、元描述和关键字词组的合理放置。
   - **Off-Page SEO**：通过外部链接和社交媒体等方式提高网站的权威性和可见性5。

5. **技术SEO**：

   - 优化网站的加载速度、移动适应性等技术因素，以提高用户体验和搜索引擎排名5。

     ​	

---

# 2. SSR

SSR通常指的是“Server-Side Rendering”，即服务器端渲染。这是一种网页渲染技术，其基本原理是在服务器上将网页的HTML内容渲染好，然后将渲染完成的HTML页面直接发送给用户浏览器。以下是SSR的一些关键点：

1. **性能优势**：对于需要快速显示首屏内容的网站来说，SSR可以减少用户等待时间，提升用户体验。
2. **SEO友好**：由于服务器端渲染的页面是完整的HTML内容，因此对于搜索引擎的爬虫来说更友好，有助于提升网站的SEO排名。
3. **前后端分离**：SSR可以实现前后端分离开发，即后端负责数据处理和页面渲染，前端负责用户界面的交互逻辑。
4. **可维护性**：服务器端渲染有助于统一数据管理和页面渲染逻辑，便于维护和更新。
5. **对比客户端渲染**：与客户端渲染（Client-Side Rendering）相比，SSR可以减少客户端的计算量，尤其适用于那些没有或限制JavaScript功能的浏览器。

SSR在流行的前端框架中得到了广泛应用，如React、Vue和Angular等，它们都提供了服务器端渲染的解决方案。

然而，SSR也有其局限性，比如会增加服务器的负载，可能需要更多的服务器资源来处理渲染任务。因此，在实际应用中，开发者需要根据具体的应用场景和需求来权衡是否使用SSR。

---

# 3. SSR可以提升SEO

SSR（Server-Side Rendering，服务器端渲染）可以优化SEO（搜索引擎优化）的原因主要在于以下几个方面：

1. **更快的索引速度**：搜索引擎爬虫（如Google的爬虫）在抓取网页时，SSR可以立即提供已经渲染好的HTML内容，这意味着爬虫不需要等待JavaScript执行完毕就能看到页面的内容，从而加快了索引速度。
2. **更好的内容可访问性**：由于SSR直接在服务器上渲染出完整的HTML，所以搜索引擎可以更容易地读取和解析页面内容，包括文本、标题、元数据等，这对于SEO来说至关重要。
3. **减少搜索引擎爬虫的工作量**：如果使用客户端渲染（Client-Side Rendering, CSR），搜索引擎爬虫可能需要执行JavaScript来渲染页面内容，这不仅增加了爬虫的工作量，而且有些搜索引擎爬虫可能不支持或限制JavaScript的执行，导致内容无法被正确索引。
4. **提高用户体验**：SSR可以提供更快的首次内容加载时间，这有助于提高用户体验，而用户体验是搜索引擎排名的一个间接因素。如果用户在搜索结果中点击了你的链接，并且能够快速看到内容，这可能会提高页面的排名。
5. **避免“爬虫陷阱”**：在客户端渲染的应用中，可能会出现爬虫陷阱，比如由于JavaScript动态加载内容导致的无限滚动页面，这可能会让搜索引擎爬虫陷入无法继续抓取其他页面的困境。SSR可以避免这类问题，因为它在服务器端就提供了完整的页面内容。
6. **结构化数据支持**：SSR允许更容易地在HTML中嵌入结构化数据（如JSON-LD），这有助于搜索引擎更好地理解页面内容，并可能提高在搜索结果中的展示效果（例如，出现富媒体搜索结果）。

总之，SSR通过提供更友好的页面内容给搜索引擎爬虫，有助于提高网站的SEO表现。然而，值得注意的是，随着搜索引擎技术的发展，现代搜索引擎越来越擅长处理客户端渲染的页面，但是SSR依然是一个有效的策略，尤其是在对SEO要求较高的场景中。

---

# 4. 什么时候引发数据更新

来自组件自身的状态 data 在一定条件下会触发组件更新更新。如果数据在模板（页面）里使用了，且数据赋值了，而且赋值前后的值不一样，那么会引起组件的更新，因为这影响了组件里的模板显示结果。例如，在代码中如果对组件中的 data 属性进行修改，并且新值与旧值不同，那么 Vue 会检测到这个变化，并自动更新组件的视图。然而，如果数据赋值了，但是赋值前后的值一样的，不会引起组件的更新，因为没有影响组件里的模板显示结果。另外，**Vue 在实例化的时候，会对 data 下面的数据进行 getter 和 setter 的转化，对这个数据做了一个中间的代理层。当组件在渲染的时候，data 里面的数据在模板中用到了它，就会把它放到 watcher 中，在 watcher 中的数据修改时就会触发组件更新，反之，如果没有用到数据就不会进入 watcher 中，修改这些数据时就不会触发组件更新。**

---

# 5. v-if v-for

1. 永远不要把 `v-if` 和 `v-for` 同时用在同一个元素上，带来性能方面的浪费（每次渲染都会先循环再进行条件判断）
2. 如果避免出现这种情况，则在外层嵌套`template`（**页面渲染不生成`dom`节点**），在这一层进行v-if判断，然后在内部进行v-for循环

```js
<template v-if="isShow">
    <p v-for="item in items">
</template>
```

3. 如果条件出现在循环内部，可通过计算属性`computed`提前过滤掉那些不需要显示的项

```js
computed: {
    items: function() {
      return this.list.filter(function (item) {
        return item.isShow
      })
    }
}
```

---

# 6.明明跨域是浏览器禁止的，那为什么服务器可以解决？

跨域问题（CORS, Cross-Origin Resource Sharing）本质上是浏览器的一种安全机制，用于限制一个源（origin）的文档或脚本如何与另一个源的资源进行交互。这种机制是为了防止恶意网站通过脚本获取用户在其他网站上的敏感数据，即所谓的“跨站脚本攻击”（XSS）。

当浏览器发现一个请求违反了同源策略时，它会阻止前端JavaScript代码访问响应的内容，除非服务器明确地指定了允许这样的跨域请求。这就是为什么说跨域是由浏览器禁止的原因——因为这个限制是在客户端（浏览器）执行的。

然而，服务器可以通过配置来解决跨域问题。具体来说，服务器可以设置HTTP响应头中的`Access-Control-Allow-Origin`字段，来告诉浏览器哪些源是可以被信任并允许跨域请求的。例如，如果服务器设置了`Access-Control-Allow-Origin: *`，则表示允许任何源发起的请求；或者可以指定具体的源，如`Access-Control-Allow-Origin: https://example.com`，这样就只允许来自`https://example.com`的请求。

此外，对于某些复杂的跨域请求（比如使用PUT方法、DELETE方法等），浏览器可能会先发送一个预检请求（OPTIONS请求），以确认实际请求是否安全可执行。这时服务器需要正确处理这些预检请求，并返回适当的CORS头部信息。

总结来说，虽然跨域限制是在浏览器端实施的，但服务器可以通过设置正确的HTTP头部来指示浏览器允许特定的跨域请求，从而实现对跨域问题的解决。

---

# 7. webpack和Vite有什么区别？

其实这两个工具能提供的技术能力有很大的重叠度或者相似度，基本就是对前端代码进行打包构建处理。区别是 Vite 内置了很多工具，可以减少很多配置工作量；而 Webpack 只是简单的打包工具架子，需要开发者一开始准备很多配置处理，不像 Vite 那样能开箱即用，需要花些功夫进行选择 Webpack 的 Loader 和 Plugin 进行配置。

![img](https://static001.geekbang.org/resource/image/00/68/0012a0ab91a7db94cdd118eae4bc2c68.png?wh=1920x1082)

---

# 8. ESM

在上述句子中，"ESM"指的是“ECMAScript Modules”，这是JavaScript模块的标准格式，用于前端开发中的代码组织和模块化。以下是关于ECMAScript Modules（ESM）的一些详细信息：

**ECMAScript Modules（ESM）**：

- ESM是ECMA International制定的标准，用于JavaScript模块化编程。
- 它允许开发者通过使用`import`和`export`语句来导入和导出模块。
- ESM是原生支持在现代浏览器中的，这意味着不需要额外的工具或库来使用模块化特性。
- ESM提供了诸如静态模块结构、循环引用处理、以及更好的代码优化和打包等特性。

**Vite利用ESM的特性**：

- Vite是一个现代化的前端构建工具，它利用了浏览器对ESM的原生支持，从而提供快速的开发体验。
- 在开发模式下，Vite不需要像传统的构建工具（如Webpack）那样进行预编译和打包，而是直接利用浏览器解析ESM的能力，按需加载模块。
- 这使得开发环境中的热更新（HMR - Hot Module Replacement）非常快速，因为Vite只需更新变更的模块，而不是整个应用。
- 在生产构建时，Vite仍然会使用Rollup等工具来打包应用，以确保兼容性和性能优化。

---

# 9. Bundle文件

Bundle文件通常是指由前端构建工具（如Webpack、Rollup、Parcel或Vite等）生成的文件，它包含了应用程序的所有资源（如JavaScript代码、CSS样式、图片、字体等），这些资源被处理和优化后，合并成一个或多个文件，以便在浏览器中使用。
Bundle文件的格式通常有以下几种：
1. **JavaScript Bundle**:
   - 这是最常见的bundle文件类型，通常具有`.js`扩展名。
   - 它包含了所有的JavaScript代码以及可能被转换为JavaScript的其它资源（例如，通过Webpack的loaders处理的CSS或图片）。
   - JavaScript bundle可以是CommonJS模块、AMD模块或ESM模块格式，具体取决于构建工具的配置和目标环境。
2. **CSS Bundle**:
   - CSS bundle文件通常具有`.css`扩展名。
   - 它包含了所有的样式信息，这些样式可能来自多个源文件，但最终被合并成一个文件。
   - CSS bundle可能会经过压缩和优化，以减少文件大小和提高加载速度。
3. **Web Bundle**:
   - 这是一个较新的格式，由Google提出，旨在通过单个HTTP/2请求加载多个资源。
   - 它具有`.wbn`扩展名，并且可以包含HTML、JavaScript、CSS、图片等资源。
4. **Asset Bundle**:
   - 这通常指的是非代码资源的集合，如图片、字体、SVG等。
   - 这些资源可能被优化（如压缩图片、合并字体文件等）并打包在一起，但它们不一定合并成一个单一文件。
   在构建过程中，bundle文件的具体格式和结构取决于以下因素：
- **构建工具**：不同的构建工具可能会生成不同格式的bundle文件。
- **配置**：构建工具的配置选项会影响bundle文件的输出格式，例如是否启用模块化、压缩、源映射（source maps）等。
- **目标环境**：目标浏览器或服务器环境可能会影响bundle文件的兼容性和优化方式。
总的来说，bundle文件是一种经过优化和处理的资源集合，旨在提高应用程序的性能和可维护性。

---

# 10. Render函数

在Vue.js框架中，`render` 函数是一个可选的配置项，它提供了一个更接近编译器的方式，让你能够自定义Vue组件的渲染逻辑。当你使用Vue并且不使用template模板选项时，或者需要在编译过程中进行更细粒度的控制时，`render` 函数非常有用。
以下是`render`函数的几个主要用途：
1. **创建虚拟节点（VNodes）**：
   `render` 函数直接返回虚拟节点（VNode），这是Vue的虚拟DOM系统中的一个概念。VNode是一个简单的JavaScript对象，它描述了应该渲染的DOM结构。
2. **替代模板（template）**：
   如果你的组件没有使用`template`选项，或者你想要在构建过程中通过编译器（如Babel）进一步优化你的组件，你可以使用`render`函数来定义组件的渲染逻辑。
3. **提高性能**：
   使用`render`函数可以避免运行时编译模板的性能开销，因为`render`函数是在组件的创建阶段就已经编译好的。
4. **更灵活的渲染控制**：
   `render`函数提供了更高级的编程能力，允许你基于JavaScript的逻辑来动态地生成DOM结构，这在某些复杂场景下非常有用。
   下面是一个简单的`render`函数的例子：
```javascript
Vue.component('my-component', {
  render(createElement) {
    // `createElement` 是一个函数，用于创建虚拟节点
    // 它接收一个标签名、一个数据对象和一个子节点数组
    return createElement('div', {
      // 数据对象可以包含属性、事件监听器等
      attrs: {
        id: 'my-div'
      }
    }, [
      // 子节点可以是一个字符串，也可以是其他虚拟节点
      createElement('h1', 'Hello World'),
      'Some text'
    ]);
  }
});
```
在上面的例子中，`render`函数使用`createElement`函数来创建一个包含`h1`标签和文本的`div`元素。
总的来说，`render`函数是Vue中一个强大的特性，它让你能够以编程的方式定义组件的输出，这在需要高度自定义渲染逻辑时非常有用。

---

# 11. 解除响应式

在 Vue 3 中，响应式系统通过 Proxy 对象使得数据变化能够自动更新到视图上，这是 Vue 响应式数据的核心特性。然而，在某些特定场景下，解除数据的响应式是有必要的，以下是一些可能需要解除响应式数据的场景：
1. **性能优化**：
   - 当你有大量数据需要处理，而这些数据不需要在模板中展示或者不需要响应式更新时，保持它们的响应式状态可能会造成不必要的性能开销。在这种情况下，解除响应式可以减少观察者的数量，提高性能。
2. **避免不必要的渲染**：
   - 如果一个组件不需要响应式数据变化来重新渲染，那么解除这些数据的响应式可以避免组件不必要的重新渲染。
3. **与第三方库集成**：
   - 当使用第三方库时，这些库可能不期望数据是响应式的。如果将响应式数据传递给这些库，可能会导致错误或不可预见的行为。解除响应式可以保证第三方库正常工作。
4. **深拷贝**：
   - 在进行深拷贝操作时，你可能不希望拷贝的数据保持响应式。如果拷贝的数据是响应式的，那么原数据和拷贝的数据之间的更改将会互相影响。
5. **服务器端渲染（SSR）**：
   - 在服务器端渲染时，由于不需要响应式数据来驱动视图更新，解除响应式可以减少内存使用，并提高渲染效率。
6. **数据持久化**：
   - 当需要将数据保存到本地存储（如localStorage）或发送到服务器时，通常不需要这些数据是响应式的。因此，在持久化之前，可以解除数据的响应式。
7. **创建原始数据的副本**：
   - 有时你可能需要创建一个响应式数据的非响应式副本，以便在不影响原始数据的情况下进行操作。
   在 Vue 3 中，可以使用 `toRaw` 函数来获取响应式代理的原始数据，从而解除其响应式。以下是一个示例：
```javascript
import { reactive, toRaw } from 'vue';
const reactiveData = reactive({ count: 1 });
const rawData = toRaw(reactiveData);
// 现在 rawData 是非响应式的
```
请注意，使用 `toRaw` 获取到的原始数据之后，对其进行修改不会触发界面更新。因此，应当谨慎使用，并确保在适当的场景下使用解除响应式操作。

---

# 12. 组件通信的替代方式？

我们把公共数据都放在一个响应式数据的文件里，无论是父组件还是子组件，都直接引用这个文件里的数据，然后直接在各自组件间进行读数据或写数据。如果有组件里的模板视图使用到这个公共响应式数据，数据被其它组件修改，也会同时触发模板视图的更新。

总结: 使用公共存储+Watch监听

---

# 13.  TS TypeScript

说到 TypeScript，你应该或多或少听说过，它是 JavaScript 的“超集”，也就是说 JavaScript 是 TypeScript 的子集。众所周知，JavaScript 是弱类型的语法，定义的数据可以随意赋值其它数据类型，这个弱类型特性很容易给代码在运行时候留下隐患。

---

# 14. Less

Less 是 CSS 的“预处理语言”，意思是可以让 CSS 像写 JavaScript 那样支持变量、循环、继承和自定义方法等多种特性，极大提高 CSS 的开发效率和样式复用率，最终再通过工具编译成 CSS 代码。

---

