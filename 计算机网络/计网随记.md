## 1. TLS/SSL

1. HTTPS的TLS/SSL协议的具体流程如下： 
   1. 客户端向服务器发送请求连接，请求使用SSL/TLS加密通信。
   
      服务器向客户端发送证书，证书中包含公钥。
   
   2. 客户端验证证书的合法性，如果合法则生成一个随机数并使用公钥加密后发送给服务器。
   
   3. 服务器使用自己的私钥解密客户端发送过来的随机数，同时使用证书中的公钥加密一个确认信息发送给客户端。
   
   5. 客户端验证服务器发送过来的确认信息，如果合法则连接建立。
   
---

## 2. HTTPS的加密与认证过程？重要

#### [#](https://www.csview.cn/network/http.html#clienthello)ClientHello

首先，由客户端向服务端发起加密通信请求。客户端主要向服务端发送：

- 客户端支持的 SSL/TLS协议版本
- 客户端产生的的随机数(Client Random）
- 客户端支持的密码套件列表

#### [#](https://www.csview.cn/network/http.html#severhello)SeverHello

服务器收到客户端请求后，向客户端发出响应。服务端回应的内容有：

- 确认 SSL/ TLS 协议版本(如果浏览器不支持，则关闭加密通信）
- 服务端生产的随机数(Server Random）
- 确认的密码套件列表
- 服务端的数字证书

#### [#](https://www.csview.cn/network/http.html#客户端回应)客户端回应

客户端收到服务端的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务端的数字证书的真实性。如果证书没有问题，客户端会从数字证书中取出服务端的公钥，然后使用它加密报文，向服务端发送如下信息：

- 一个随机数，该随机数会被服务端公钥加密
- 加密通信算法改变通知，表示随后的信息都将用会话秘钥加密通信
- 客户端握手结束通知，表示客户端的握手阶段已经结束
- 之前所有内容的发生的数据做个摘要，用来供服务端校验

服务端和客户端有了三个随机数，接着用双方协商的加密算法，各自生成本次通信的会话秘钥。

#### 服务端回应

服务端收到客户端的第三个随机数(pre-master key）之后，通过协商的加密算法，计算出本次通信的会话秘钥。服务端向客户端发送最后的信息：

- 加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信
- 服务端握手结束通知，表示服务端的握手阶段已经结束
- 之前所有内容的发生的数据做个摘要，用来供客户端校验

接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议。



---

## 3. TCP 降低网络负载

TCP使用**Nagle算法**来降低网络负载。这个算法通过减少网络上的小数据包数量，从而减轻网络负荷并提高传输效率。

---

## 4. 子网掩码计算

![image-20231024114847369](../../../AppData/Roaming/Typora/typora-user-images/image-20231024114847369.png)

---

## 5. 计网七层常见的协议

1. 物理层（Physical Layer）：

   - USB
   - HDMI

2. 数据链路层（Data Link Layer）：

3. 网络层（Network Layer）：

   - IP（Internet Protocol）

4. 传输层（Transport Layer）：

   - TCP（Transmission Control Protocol）
   - UDP（User Datagram Protocol）

5. 会话层（Session Layer）：

   - RPC（Remote Procedure Call）

6. 表示层（Presentation Layer）：

   - SSL/TLS（Secure Sockets Layer/Transport Layer Security）

7. 应用层（Application Layer）：

   - HTTP（Hypertext Transfer Protocol）
   - SMTP（Simple Mail Transfer Protocol）
   - POP3（Post Office Protocol Version 3）
   - FTP（File Transfer Protocol）
   - DNS（Domain Name System）

   
   ---
   
## 6. TCP靠什么保证运输

   TCP（Transmission Control Protocol，传输控制协议）通过以下几种机制来保证可靠连接：

   1. 建立连接：TCP通过三次握手（three-way handshake）建立连接。在数据传输开始之前，客户端和服务器需要交换一系列的数据包来确认双方都已准备好进行数据传输。
   2. 数据包编号：TCP给每个数据包分配一个序列号，这样接收端可以按正确的顺序重新组合收到的数据包。
   3. 确认与重传：接收端会给发送端发送确认（ACK）数据包，表示已成功接收到特定的数据包。如果发送端在一定时间内未收到确认，它会重传数据包，直到收到确认或超过重传次数限制。
   4. 流量控制：TCP使用滑动窗口机制进行流量控制。接收端告知发送端可接受的最大数据量，从而避免因接收端处理能力不足而导致的数据丢失。
   5. 拥塞控制：TCP通过拥塞控制算法（如慢开始、拥塞避免、快重传和快恢复）来避免网络拥塞。当检测到网络拥塞时，发送端会减慢发送速率，以降低数据包丢失的风险。

   这些机制共同作用，使TCP成为一种高度可靠的传输协议。

---

## 7. NIO 零拷贝

   零拷贝是提升 IO 操作性能的一个常用手段，像 ActiveMQ、Kafka 、RocketMQ、QMQ、Netty 等顶级开源项目都用到了零拷贝。

   零拷贝是指计算机执行 IO 操作时，CPU 不需要将数据从一个存储区域复制到另一个存储区域，从而可以减少上下文切换以及 CPU 的拷贝时间。也就是说，零拷贝主主要解决操作系统在处理 I/O 操作时频繁复制数据的问题。零拷贝的常见实现技术有： `mmap+write`、`sendfile`和 `sendfile + DMA gather copy` 。

   下图展示了各种零拷贝技术的对0比图：





   |                            | CPU 拷贝 | DMA 拷贝 | 系统调用   | 上下文切换 |
   | -------------------------- | -------- | -------- | ---------- | ---------- |
   | 传统方法                   | 2        | 2        | read+write | 4          |
   | mmap+write                 | 1        | 2        | mmap+write | 4          |
   | sendfile                   | 1        | 2        | sendfile   | 2          |
   | sendfile + DMA gather copy | 0        | 2        | sendfile   | 2          |

   可以看出，无论是传统的 I/O 方式，还是引入了零拷贝之后，2 次 DMA(Direct Memory Access) 拷贝是都少不了的。因为两次 DMA 都是依赖硬件完成的。零拷贝主要是减少了 CPU 拷贝及上下文的切换。

   Java 对零拷贝的支持：

   - `MappedByteBuffer` 是 NIO 基于内存映射（`mmap`）这种零拷⻉⽅式的提供的⼀种实现，底层实际是调用了 Linux 内核的 `mmap` 系统调用。它可以将一个文件或者文件的一部分映射到内存中，形成一个虚拟内存文件，这样就可以直接操作内存中的数据，而不需要通过系统调用来读写文件。
   - `FileChannel` 的`transferTo()/transferFrom()`是 NIO 基于发送文件（`sendfile`）这种零拷贝方式的提供的一种实现，底层实际是调用了 Linux 内核的 `sendfile`系统调用。它可以直接将文件数据从磁盘发送到网络，而不需要经过用户空间的缓冲区。关于`FileChannel`的用法可以看看这篇文章：[Java NIO 文件通道 FileChannel 用法open in new window](https://www.cnblogs.com/robothy/p/14235598.html)。

---

## 8.  RPC 和 HTTP 的区别

RPC（远程过程调用，**会话层**）和HTTP（超文本传输协议，**应用层**）之间存在一些关键区别。总的来说，RPC是一种通信协议，它允许一台计算机（客户端）通过网络调用另一台计算机（服务器）上的程序或方法，而无需了解底层网络技术的细节。HTTP则是一种应用层协议，用于在网络中传输超文本（例如网页），它定义了客户端和服务器之间的通信方式。

以下是RPC和HTTP的具体区别：

1. **调用方式**：RPC采用的是请求-响应模型，客户端发起请求，等待服务器响应。而HTTP采用的是无状态的请求-响应模型，意味着服务器不会为每个请求保持状态。
2. **传输方式**：RPC可以使用多种传输协议，如TCP、UDP等，而HTTP主要基于TCP传输协议。
3. **传输内容**：RPC可以传输任意类型的数据，包括二进制数据，因此其数据传输效率较高。HTTP则主要用于传输文本数据，通常需要将数据转换为文本格式（如JSON、XML）进行传输，数据传输效率相对较低。
4. **接口定义**：RPC通常需要定义严格的接口，客户端和服务器需要按照接口进行编程。而HTTP的接口通常更为灵活，可以通过URI和HTTP方法进行访问和操作。
5. **错误处理**：RPC通常有更完善的错误处理机制，能够提供更详细的错误信息。而HTTP的错误处理通常较为简单，主要通过HTTP状态码进行错误标识。
6. **使用场景**：RPC通常用于内部系统之间的通信，或者在需要高效率、低延迟的场景下使用。而HTTP则更常用于Web应用和服务之间的通信，以及在需要跨平台、跨语言的场景下使用。

总的来说，RPC和HTTP各有其特点和优势，选择哪种协议取决于具体的应用场景和需求。

---

## 9. URI 和 URL 的区别？

URI（统一资源标识符）和URL（统一资源定位符）的区别如下：

1. 定义：URI是一个用于标识互联网资源的字符串序列，它关注的是资源的标识符，而不关注资源的位置。URL则是URI的一种特殊类型，它提供了资源在互联网上的位置信息。可以说，URL是互联网上资源的具体地址，而URI是这个地址的抽象标识。
2. 格式：一般来说，URL的格式为“协议地址://ip/文件夹”，它指向互联网上特定位置的资源。而URI的格式更为广泛，它包括协议、主机名、端口号、路径、参数、查询和片段等部分，用于唯一地标识和命名资源。
3. 使用范围：URL主要用于定位互联网上的资源，是URI的一个子集。而URI则是一种更广义的标识符，不仅可以用于URL，还可以用于标识其他类型的资源，如URN（统一资源名称）。

总的来说，URL和URI都是用于标识和访问互联网资源的标识符，但它们在定义、格式和使用范围上存在一些差异。可以简单理解为，URL是URI的一种具体形式，用于定位互联网上特定位置的资源。

---

## 10. HTTP 报文结构

HTTP报文结构由请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。请求行包含请求方法、URL、协议版本，请求头部包含请求的附加信息，以键值对的形式存在，空行用来分隔请求头部和请求数据，请求数据是可选的，比如GET请求就没有请求数据。

---

## 11. HTTP 常见的状态码

#### 一、1开头的状态码(信息类)

> 100，接受的请求正在处理，信息类状态码

#### 二、2开头的状态码(成功类)

> 2xx(成功)表示成功处理了请求的状态码
> 200(成功)服务器已成功处理了请求。

#### 三、3开头的状态码(重定向)

> 3xx，(重定向)表示要完成请求，需要进一步操作。通常这些状态代码用来重定向。
> 301，永久性重定向，表示资源已被分配了新的 URL
> 302，临时性重定向，表示资源临时被分配了新的 URL**（java 重定向）**
> 303，表示资源存在另一个URL，用GET方法获取资源
> **304，(未修改)自从上次请求后，请求网页未修改过。服务器返回此响应时，不会返回网页内容（缓存）**

#### 四、4开头的状态码(客户端错误)

> 4xx(请求错误)这些状态码表示请求可能出错，妨碍了服务器的处理
> 400(错误请求)服务器不理解请求的语法
> 401表示发送的请求需要有通过HTTP认证的认证信息
> 403(禁止)服务器拒绝请求
> 404(未找到)服务器找不到请求网页

#### 五、5开头的状态码(服务器错误)

> 5xx(服务器错误)这些状态码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求的错误
> 500，(服务器内部错误)服务器遇到错误，无法完成请求
> 503，表示服务器处于停机维护或超负载，无法处理请求

---

