##  1.  索引

联合索引及索引最左匹配原

 联合索引相比于多个单独的索引，在一定程度上减少索引的存储空间和减少在查询索引时对磁盘的IO。

  在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。所以在联合索引查询时应该按照建立索引时的顺序书写查询条件。

**在这个条件语句中，只有a用到了索引，后面的b,c就不会用到索引。这就是“如果遇到范围查询(>、<、between、like等)，就停止后边的匹配。”的意思。**

```mysql
select * from table where a=1 (使用索引)

select * from table where a=1 and b=1 (使用索引)

select * from table where a=1 and b=1 and c=1 (使用索引)

select * from table where a=1 and c=1 (使用索引)

select * from table where c=1 and b=1 (索引失效)

where a = xxx
where a = xxx and b = xxx
where a = xxx and b = xxx and c = xxx
where a like 'xxx%'
where a > xxx
where a = xxx order by b
where a = xxx and b = xxx order by c group by a

```



> 如详细了解，可阅读知乎《面试前必须要掌握的MySQL索引最左前缀匹配原则》，原文链接：[面试前必须要掌握的MySQL索引最左前缀匹配原则 - 知乎](https://zhuanlan.zhihu.com/p/144853595)

**2、字段和字段值上做计算和类型对索引的影响**

  一、在索引字段上使用计算类函数，会将字段转换成临时字段，从而无法对应索引，致使索引失效。

  二、使用索引字段做查询条件时，‘=’左右两边值的类型保持一致，如果不一致什么导致索引字段类型转换变成临时字段。

  三、在使用like的问题上尽量使用右%（like 'abc%'），在索引匹配时mysql遵照即最左优先。

  四、**索引字段不要使用NULL，因为NULL是一个特殊的值需要单独处理。单列索引不存储null值，复合索引不存储全为null的值。索引不能存储Null，所以对这列采用is null条件时，因为索引上根本没Null值，不能利用到索引，只能全表扫描。**

**3、为什么select字段往往使用索引字段比非索引字段要快**

  一、select字段尽量不要使用'*',在使用*作为输入字段时，引擎在查询时会先从字典表中查找出所有字段然后在匹配输出。

  二、**使用索引字段作为select输出字段速度快的主要原因在于，查询时引擎无需从磁上读取字段数据，直接从索引节点上返回数据。当然，如果列中存在非索引字段引擎不会从索引节点上返回数据，会从数据节点返回数据，这样索引列失效**。

  三、非索引字段一定比索引字段要慢么？事实上，如果查询还需要拿别的字段(如sex)，那么光查询索引就不够了，必须扫表。注意！在这里 mysql 查询引擎就会对两种情况做判断： 1). 从索引索引拿到对应id=12的主键id，然后根据id去表中拿结果。 2).直接全表扫描。

  这里很多人有一个误区，认为1是好的，2是不好的。这是不对滴。全表扫描有时候会比先过索引在查表要快！

  先说走索引的情况，比如说满足dept_id=12的主键id有1w个，而且均匀分布在不同的page里，那么mysql需要一个page一个page的把结果读取出来(random io)。需要磁盘io 1w次。

  全表扫描的话，再比如全表有10w条记录，表文件为400m 大小(不少了吧)，那么因为是顺序读盘，一次最多读1m数据，那么只需要磁盘io 400次。

> 本节参考：
>
> [《mysql没有索引的字段_MySQL-mysql索引与select字段不是没关系吗？》](https://blog.csdn.net/weixin_33510623/article/details/113645248?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&spm=1001.2101.3001.4242)
>
> [《MySQL在有索引列情况下select *的输出结果顺序》](https://blog.csdn.net/maray/article/details/8477612)

**4、为什么order by字段上使用索引字段更快**

  B+树的索引都是按照顺序存储的，所以在对结果处理时无需做过多的排序操作。

**5、多表关键查询时，为什么要小表驱动大表（小表在前，大表在后）**

一、驱动表的定义
当进行多表连接查询时， [驱动表] 的定义为：

1）指定了联接条件时，满足查询条件的记录行数少的表为[驱动表]

2）未指定联接条件时，行数少的表为[驱动表]（Important!）

忠告：如果你搞不清楚该让谁做驱动表、谁 join 谁，请让 MySQL 运行时自行判断

既然“未指定联接条件时，行数少的表为[驱动表]”了，而且你也对自己写出的复杂的 Nested Loop Join 不太有把握（如下面的实例所示），就别指定谁 left/right join 谁了，请交给 MySQL优化器 运行时决定吧。





**InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。**

**MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。**

---

##   2.  不可重复读和幻读有什么区别？

- 不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；
- 幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。

---

## 3.  MySQL 的默认隔离级别是什么?

- MySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）**

🤣

##  4.  MySQL 解决幻读的方法？

MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种：

针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。

针对当前读（select ... for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。



---

## 5. 为什么建议MySQL列属性尽量用 NOT NULL？

在项目中优化mysql的时候字段尽量不要用NULL 值，使用-1或者其他特殊标识来替代，原因如下：

* 为NULL的列会使用更多的存储空间，在Mysql中也需要特殊处理
* 对Mysql来说更难优化，因为可为NULL的列会使索引统计和值比较都更复杂。
* 当可为NULL的列被索引时，每个索引记录需要一个额外的字节，在MyISAM里甚至还可能导致固定大小的索引（例如只有一个整数列的索引）变成可变大小的索引。

------------------------------------------------

## 6. 索引下推

索引下推是索引下推是 MySQL 5.6 及以上版本上推出的，用于对查询进行优化。

索引下推是把本应该在 server 层进行筛选的条件，下推到存储引擎层来进行筛选判断，这样能有效减少回表。

举例说明：

首先使用联合索引（name，age），现在有这样一个查询语句：

```mysql
select *  from t_user where name like 'L%' and age = 17;
1
```

这条语句从最左匹配原则上来说是不符合的，原因在于只有name用的索引，但是age并没有用到。

**不用索引下推的执行过程：**

```mysql
第一步：利用索引找出name带'L'的数据行：LiLei、Lili、Lisa、Lucy 这四条索引数据
第二步：再根据这四条索引数据中的 id 值，逐一进行回表扫描，从聚簇索引中找到相应的行数据，将找到的行数据返回给 server 层。
第三步：在server层判断age = 17,进行筛选，最终只留下 Lucy 用户的数据信息。
123
```

使用索引下推的执行过程：

```
第一步：利用索引找出name带'L'的数据行：LiLei、Lili、Lisa、Lucy 这四条索引数据
第二步：根据 age = 17 这个条件，对四条索引数据进行判断筛选，最终只留下 Lucy 用户的数据信息。
（注意：这一步不是直接进行回表操作，而是根据 age = 17 这个条件，对四条索引数据进行判断筛选）
第三步：将符合条件的索引对应的 id 进行回表扫描，最终将找到的行数据返回给 server 层。
1234
```

比较二者的第二步我们发现，索引下推的方式极大的减少了回表次数。

**索引下推需要注意的情况：** ·

下推的前提是索引中有 age 列信息，如果是其它条件，如 gender = 0，这个即使下推下来也没用

**开启索引下推：**

索引下推是 MySQL 5.6 及以上版本上推出的，用于对查询进行优化。默认情况下，索引下推处于启用状态。我们可以使用如下命令来开启或关闭。

```mysql
set optimizer_switch='index_condition_pushdown=off'; 	-- 关闭索引下推
set optimizer_switch='index_condition_pushdown=on';		-- 开启索引下
```

---

## 7. delete、drop以及truncate的区别

#### 1、drop、truncate、delete它们的用法是不同的

1. drop(丢弃数据): `drop table 表名` ，直接将表都删除掉，在删除表的时候使用。
2. truncate (清空数据) : `truncate table 表名` ，只删除表中的数据，再插入数据的时候自增长id又从1开始，在清空表中数据的时候使用。
3. delete（删除数据） : `delete from 表名 where 列名=值`，删除某一列的数据，如果不加 where 子句和`truncate table 表名`作用类似。

truncate 和不带 where 子句的 delete、以及 drop 都会删除表内的数据，但是 **truncate 和 delete 只删除数据不删除表的结构(定义)，执行drop语句，此表的结构也会删除，也就是执行 drop 之后对应的表不复存在。**

#### 2、它们属于不同的数据库语言

truncate和drop 属于DDL(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。而 delete 语句是DML (数据库操作语言)语句，这个操作会放到 rollback segement 中，事务提交之后才生效。

#### 3、它们的执行速度不同

drop>truncate>delete

---

## 8. 索引的数量

在MySQL中，一张表最多支持64个索引。

---

## 9. 主键索引和唯一索引的区别

**主键一定是唯一性索引，唯一性索引并不一定就是主键。** 

所谓主键就是能够唯一标识表中某一行的属性或属性组，一个表只能有一个主键，但可以有多个候选索引。

因为主键可以唯一标识某一行记录，所以可以确保执行数据更新、删除的时候不会出现张冠李戴的错误。

主键除了上述作用外，常常与外键构成参照完整性约束，防止出现数据不一致。数据库在设计时，主键起到了很重要的作用。 

主键可以保证记录的唯一和主键域非空，数据库管理系统对于主键自动生成唯一索引，**所以主键也是一个特殊的索引**。 

2. 一个表中可以有多个唯一性索引，但只能有一个主键。 

3. **主键列不允许空值，而唯一性索引列允许空值。** 

4. 索引可以提高查询的速度。 
  

其实主键和索引都是键，不过主键是逻辑键，索引是物理键，意思就是主键不实际存在，而索引实际存在在数据库中，主键一般都要建，主要是用来避免一张表中有相同的记录，索引一般可以不建，但如果需要对该表进行查询操作，则最好建，这样可以加快检索的速度。 

首先primary key跟[unique](https://so.csdn.net/so/search?q=unique&spm=1001.2101.3001.7020)都是Constraints，属于logical object，而index则是physical object，会占用index page并被保存在磁盘上。

Primary key Constraints和unique Constraints都需要保证列是唯一的，不能有重复值，但是一张表只能有一个Primary key Constraints，但是可以有多个unique Constraints。

 

[主键](https://www.baidu.com/s?wd=主键&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)约束比[唯一索引](https://www.baidu.com/s?wd=唯一索引&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)约束严格，当没有设定[主键](https://www.baidu.com/s?wd=主键&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)时，非空[唯一索引](https://www.baidu.com/s?wd=唯一索引&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)自动称为[主键](https://www.baidu.com/s?wd=主键&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)。对于主键和[唯一索引](https://www.baidu.com/s?wd=唯一索引&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)的一些区别主要如下：

1. 主键不允许空值，唯一索引允许空值
2. 主键只允许一个，唯一索引允许多个
3. 主键产生唯一的聚集索引，唯一索引产生唯一的非聚集索引

---

## 10. 半连接

**半连接**是关系数据库中一种特殊的连接查询，主要用于返回左表中与右表至少匹配一次的数据行。这种查询通常表现为 -或者 IN 子查询。其主要特点是只会返回左表中的数据，而右表只用于条件判断。即使右表中存在多个匹配的数据，左边中的数据也只返回一次。半连接通常用于存在性判断，例如判断哪些顾客购买了产品，而不需要知道他们购买的具体产品和数量。

---

## 11. SQL执行顺序

MySQL中查询语句的执行顺序如下：

1. FROM：首先选择需要查询的表，确定数据的来源。
2. JOIN：如果查询涉及到多个表，需要通过 JOIN 操作将多个表连接起来。
3. WHERE：对连接后的表进行筛选，过滤掉不符合条件的记录。
4. GROUP BY：如果需要对结果进行分组，使用 GROUP BY 子句将结果按照指定的列进行分组。
5. HAVING：对分组后的结果进行筛选，过滤掉不符合条件的分组。
6. SELECT：选择需要输出的列。
7. DISTINCT：如果需要去重，使用 DISTINCT 关键字进行去重操作。
8. ORDER BY：对结果进行排序，默认是升序排列。
9. LIMIT：如果需要限制输出结果的数量，使用 LIMIT 子句限制输出的记录数。

以上是 MySQL 中查询语句的执行顺序，可以根据具体的需求和查询语句进行适当调整。

---

## 12. 三大范式

第一范式(1NF)：属性不可分割，即每个属性都是不可分割的原子项。(实体的属性即表中的列)

第二范式(2NF)：满足第一范式；且不存在部分依赖，即非主属性必须完全依赖于主属性。(主属性即主键；完全依赖是针对于联合主键的情况，非主键列不能只依赖于主键的一部分)

第三范式(3NF)：满足第二范式；且不存在传递依赖，即非主属性不能与非主属性之间有依赖关系，非主属性必须直接依赖于主属性，不能间接依赖主属性。（A -> B, B ->C, A -> C）

---

## 13. mysql递归函数

![image-20231103160107633](../../../AppData/Roaming/Typora/typora-user-images/image-20231103160107633.png)

---

## 14. InnoDB使用自增ID作为主键有几个原因：

1. **效率**：自增ID作为主键可以提供高效的插入操作。当插入新记录时，InnoDB可以为其分配一个新的自增ID，而无需进行复杂的主键冲突检测，从而提高了插入操作的效率。
2. **索引结构**：InnoDB的索引结构是基于B+树的，自增ID作为主键可以保证数据在插入时是顺序写入的，这样可以避免频繁的磁盘I/O操作，提高了数据库的性能。
3. **避免主键冲突**：自增ID可以确保每个新插入的记录都有一个唯一的主键值，避免了由于主键冲突而导致的插入失败和重试。
4. **易于管理**：自增ID是按顺序生成的，这使得它们易于管理和理解。此外，由于它们是唯一的，因此可以轻松地跟踪和查询特定记录。
5. **减少页分裂**：如果主键是自增ID，当数据写入时，新的记录总是添加到当前已有数据的后面，这使得InnoDB不需要频繁地拆分B+树的页。反之，如果主键是随机的，那么每次插入都可能导致页的拆分，这会导致大量的碎片和效率低下。

需要注意的是，虽然使用自增ID作为主键有很多优点，但在某些情况下可能不适合使用。例如，在高并发写入操作中，**自增ID可能会成为性能瓶颈**，因为所有写入操作都需要等待ID的自增。在这种情况下，可能需要考虑使用其他类型的主键，例如UUID等。

---

## 15. 覆盖索引

**覆盖索引（Covering Index）是指索引包含了查询所需的所有列**。也就是说，索引本身能够覆盖查询的字段需求，无需再通过回表操作来获取数据。当查询列被所建的索引覆盖时，被称为覆盖索引。这种索引是非聚集复合索引的一种形式，它包括在查询里的**Select、Join和Where子句用到的所有列**。

---



## 16. MySQL中CHAR和VARCHAR的区别有哪些？

- char的长度是不可变的，用空格填充到指定长度大小，而varchar的长度是可变的。
- char的存取数度还是要比varchar要快得多
- **char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节**。

---

## 17. MySQL索引分类

我们可以按照四个角度来分类索引。

- 按「数据结构」分类：B+tree索引、Hash索引、Full-text索引。
- 按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。
- 按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。
- 按「字段个数」分类：单列索引、联合索引。

---





