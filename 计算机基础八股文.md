# 1. 进程之间的通信方式

进程间通信（Inter-Process Communication，IPC）是指在不同进程之间传送数据或信号的一些技术或方法。进程是计算机系统进行资源分配和调度的基本单位，每个进程都拥有独立的地址空间，因此进程间通信必须通过内核提供的特定机制来进行。以下是一些常见的进程间通信方式：
1. **管道（Pipes）**：管道是一种半双工的通信方式，它可以在父子进程间或者兄弟进程间进行数据传递。分为匿名管道和命名管道两种。

2. **信号（Signals）**：信号是一种简单的异步通信机制，用于通知接收进程某个事件已经发生。

3. **消息队列（Message Queues）**：消息队列允许一个或多个进程向队列中写入消息，其他进程则可以读取队列中的消息。

4. **共享内存（Shared Memory）**：共享内存允许多个进程访问同一块内存空间，是最快的IPC方式，因为数据不需要在客户和服务进程间复制。

5. **信号量（Semaphores）**：信号量是一种同步机制，通常用于控制对共享资源的访问，可以用来实现进程间的同步或互斥。

6. **套接字（Sockets）**：套接字用于不同机器上的进程间通信，也可以用于同一机器上的进程间通信。

---

# 2 IO多路复用中select、poll和epoll的区别

## 1. select

数据结构限制：使用固定大小的 fd_set 结构体来存储待监控的文件描述符集合，这意味着可监控的文件描述符数量存在硬性上限（通常为 FD_SETSIZE，典型值为 ==1024==）。当需要监控的描述符数量超过这个限制时，需要重新定义该常量并重新编译内核，或者分批处理。

效率问题：每次调用 select 时，都需要将用户空间的 fd_set ==数据结构复制到内核空间，这在描述符数量较大时会带来额外的开销==。另外，select 在检查文件描述符状态时采用轮询方式，即逐个检查每个描述符是否就绪，其复杂度与待监控描述符的数量成正比，导致在高并发场景下的性能下降。

无事件通知机制：当某个描述符就绪时，select 不会主动通知调用者，而是需要进程不断轮询（即重复调用 select），增加了不必要的系统调用开销。

## 2. poll

改进的数据结构：poll 使用 pollfd 结构体数组代替了 select 的 fd_set，消除了描述符数量的固定限制，理论上可监控任意数量的文件描述符。不过，poll 仍然需要在每次调用时传递完整的数组到内核，如果描述符数量很大，这仍可能导致较大的复制开销。

同样采用轮询：poll 同样采用轮询方式检查文件描述符状态，其性能瓶颈与 select 类似，即随着待监控描述符数量的增长，检查效率会降低。

无事件通知机制：poll 也没有提供事件通知机制，进程仍需不断轮询以检测新的就绪事件。

##3. epoll

高效数据结构：epoll 使用了一种更加高效的数据结构（通常是红黑树）来存储待监控的文件描述符，并且仅当描述符状态改变时才会通知用户空间。这样避免了每次调用时的大规模数据复制，尤其是对于大量描述符的情况。`epoll`通过epoll_ctl()来对文件描述符进行操作，只有当事件发生时才通过==epoll_wait()来获取就绪的文件描述符，不需要每次都全量复制==，因此性能开销更小。

事件驱动：epoll 提供了事件驱动的机制。当调用 epoll_wait() 时，内核只返回已经就绪的描述符，而不是像 select 和 poll 那样遍历所有描述符。此外，epoll 支持两种工作模式： ● LT (Level Triggered)：水平触发，只要描述符处于就绪状态，每次调用都会返回。 ● ET (Edge Triggered)：边缘触发，仅当描述符状态从非就绪变为就绪时返回一次，直到下次状态变化。

事件通知：epoll 通过内核事件队列实现高效的事件通知。当任何被监控的描述符状态发生变化时，内核会自动将就绪事件放入队列中等待进程检索，减少了不必要的系统调用。

综上所述，epoll 在处理大量并发连接时具有显著优势，尤其是在高并发、大规模 I/O 操作的场景下，其无上限的描述符支持、低开销的事件通知机制以及高效的事件处理方式使其成为首选。相比之下，select 和 poll 虽然功能相似，但在面对大量描述符或高并发需求时，由于其数据结构限制、轮询机制以及缺乏事件通知的特性，可能会导致性能瓶颈和资源浪费。然而，对于描述符数量较少、对性能要求不高的应用，select 和 poll 仍能满足基本需求，并且它们的实现和使用相对简单。

---



