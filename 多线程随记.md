

## 1. 为什么 wait() 方法不定义在 Thread 中？

`wait()` 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（`Object`）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（`Object`）而非当前的线程（`Thread`）。

类似的问题：**为什么 `sleep()` 方法定义在 `Thread` 中？**

因为 `sleep()` 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。

---

## 2. 可以直接调用 Thread 类的 run 方法吗？

这是另一个非常经典的 Java 多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！

new 一个 `Thread`，线程进入了新建状态。调用 `start()`方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 `start()` 会执行线程的相应准备工作，然后自动执行 `run()` 方法的内容，这是真正的多线程工作。 但是，直接执行 `run()` 方法，会把 `run()` 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。

**总结：调用 `start()` 方法方可启动线程并使线程进入就绪状态，直接执行 `run()` 方法的话不会以多线程的方式执行。**

---

##  3. 子进程使用父进程的LocalThread

ThreadLocal 相当于是线程的一个局部静态对象，它的值的作用域是当前整个线程，别的线程是无法获取到的它的值。如果子线程想获取到父线程的ThreadLocal的值该怎么办呢？这时候可以用 InheritableThreadLocal，InheritableThreadLocal的作用就是为了解决子线程想获取到父线程的ThreadLocal的值。

使用 InheritableThreadLocal 时有一点要注意的是，InheritableThreadLocal 的实现原理是在子线程创建的时候把主线程的 InheritableThreadLocal 值的内容的引用 copy 了一份给自己用，因为是 copy 出来的，所以创建子线程之后，子线程和主线程的 InheritableThreadLocal 是相互独立的了，它们之间怎么改 InheritableThreadLocal 的值也不会同步到对方的 InheritableThreadLocal 

---

## 4. 死锁的四个条件

**死锁**是指两个或多个进程在执行过程中，因争夺资源而造成的一种僵局。产生死锁的四个必要条件是：互斥条件、请求与保持条件、不可剥夺条件和循环等待条件 。

1. 互斥条件：一个资源每次只能被一个进程使用。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不可剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。
4. 循环等待条件：若干进程间形成首尾相接循环等待资源的关系 。

---

## 5. AQS公平锁和非公平锁

公平锁，每次判断state为0时不能立即抢占，而是判断是否还有前置结点，也就是判断首节点后面是否还有结点排队等候，如果有通过cas入队。 非公平锁，新线程来了，不管有没有其他结点在排队先cas抢占，如果两次强锁失败，那么就进入到队列中，其实这和公平锁一样啦，需要排队。当没有新的线程抢占时，强锁也是按照队列先后顺序来抢的，类似公平锁。 非公平锁和公平锁 最大的区别就是新来的线程是不是插队抢占，如果它没抢到那后面就是老老实实排队，后面唤醒也要等前面的结点出队了才能唤醒，而且入队的结点可能存在饥饿。

---

## 6. 死锁 - 题型1 - 并发进程所需的最少资源数

在一个系统中，有3个并发进程，都需要同类资源4个，则该系统不会发生死锁的最少资源数是：__10__
分析：
3个并发进程

都需要同类资源4个

这意味着，这3个进程是同时执行的，而且每个进程必须拥有4个资源才能开始执行。

因为3个进程要竞争资源，所以最差的情况是均分，也就是资源被 “顺序抢到” ，比如3个并发进程，现有9个资源，最坏的情况就是，每个进程抢到3个，而题中告知，需要4个资源才能开始执行，所以这3个进程都不能开始执行，所以再加1个资源，不管这个资源被哪个进程抢到都可以开始执行，结束后释放掉资源供其他进程使用，也就不会发生死锁了。

因此，不会发生死锁的最少资源数是3×3+1=10

这类求最少资源数的问题可以总结出如下公式：

进程数目×(所需的资源数目-1) +1 = 不会发生死锁的最小资源数

总结：
保证系统不发生死锁的最小资源数，符合以下两个条件:

①给每个进程都分配所需资源最大数少一个资源

②在步骤①基础上，如果系统还剩一个剩余资源，则系统不会发生死锁

---

## 7. Stream

### 1. 分类

在Java中，Stream流分为两种类型：

- 流(Stream)：表示顺序流，按照数据源的顺序进行操作，适用于串行操作。
- 并行流(ParallelStream)：表示并行流，可以同时对数据源的多个元素进行操作，适用于并行计算。

### 2.常用API详解

使用Stream主要分为三个步骤：

- **创建流**：也即获取一个Stream对象，可以通过集合、数组或者其他方式创建一个Stream。如可以使用`Stream.of()`方法创建流；
- **进行中间操作**：对Stream进行连续的中间操作，包括过滤、映射、排序、去重等处理。如可以使用`forEach()`方法遍历流中的元素，并使用`filter()`、`map()`、`sorted()`等方法对流进行操作；
- **执行终结操作**：最后使用一个终结操作来触发计算并产生结果，如收集、聚合、遍历等。如可以使用`reduce()`方法进行元素的归约操作，使用`collect()`方法进行元素的收集操作。

|   类型   |          方法          | 作用                                                         |
| :------: | :--------------------: | ------------------------------------------------------------ |
| 中间操作 |   filter(Predicate)    | 过滤符合条件的元素                                           |
|          |     map(Function)      | 对每个元素应用转换函数                                       |
|          |   flatMap(Function)    | 将每个元素转换成Stream对象，然后将所有的Stream连接成一个Stream |
|          |       distinct()       | 去除重复的元素                                               |
|          |  sorted([Comparator])  | 排序元素，默认为自然排序                                     |
|          |        limit(n)        | 截取指定数量的元素                                           |
|          |        skip(n)         | 跳过指定数量的元素                                           |
|          |     peek(Consumer)     | 对每个元素执行操作，不影响流中的其他元素                     |
|          |  takeWhile(Predicate)  | 从开头开始连续取元素满足指定条件，直到遇到不满足条件的元素   |
|          |  dropWhile(Predicate)  | 从开头开始连续跳过元素满足指定条件，直到遇到不满足条件的元素 |
| 终结操作 |   collect(Collector)   | 将流转换为集合或其他数据结构                                 |
|          |   forEach(Consumer)    | 遍历流中的元素，并对其执行操作                               |
|          | reduce(BinaryOperator) | 使用给定的二元操作符将元素归约成一个值                       |
|          |   max([Comparator])    | 找出流中的最大值                                             |
|          |   min([Comparator])    | 找出流中的最小值                                             |
|          |       toArray()        | 将流中的元素转换为数组                                       |
|          |        count()         | 统计流中的元素数量                                           |
|          |      findFirst()       | 返回满足条件的第一个元素                                     |
|          |       findAny()        | 返回任意满足条件的元素                                       |
|          |  anyMatch(Predicate)   | 判断流中是否存在任意一个元素满足给定条件                     |
|          |  allMatch(Predicate)   | 判断流中所有元素是否都满足给定条件                           |
|          |  noneMatch(Predicate)  | 判断流中是否没有任何元素满足给定条件                         |

---

## 8. 内存溢出与内存泄漏区别

### 内存溢出（Memory Overflow）
内存溢出发生在程序尝试分配超过系统可用的内存空间时。这通常是因为程序中的某些部分错误地创建了大量的对象或者数据结构，或者是因为程序试图处理比预期更大的数据集。内存溢出可能导致程序崩溃或产生不可预测的行为。
内存溢出可以分为几种类型：
1. **栈溢出**：当程序的调用栈深度超过操作系统分配给它的栈空间大小时，会发生栈溢出。
2. **堆溢出**：当程序在堆上请求的空间超过了操作系统或内存管理器允许的最大堆大小时，会发生堆溢出。
### 内存泄漏（Memory Leak）
内存泄漏是指程序在申请内存后未能正确释放已不再使用的内存。随着程序的运行，泄漏的内存会逐渐累积，导致可用内存逐渐减少，最终可能导致内存溢出或降低系统性能。
内存泄漏通常是由以下原因引起的：
1. **忘记释放**：程序在动态分配内存后忘记释放。
2. **无效引用**：对象被分配后，仍然有引用指向它，但这个引用已经不再有效或不再需要。
### 总结区别
- **内存溢出**是程序尝试使用超过系统限制的内存。
- **内存泄漏**是程序未能释放不再使用的内存，导致内存逐渐耗尽。
在软件开发中，应当通过代码审查、内存分析工具和良好的编程习惯来避免这两种问题。

---

## 9. Shutdown和ShutdownNow有什么区别？

`Shutdown`和`ShutdownNow`是Java中的`ExecutorService`接口提供的两种关闭线程池的方法。它们的主要区别在于关闭的温和程度和对正在执行任务的线程的处理方式。
1. **shutdown()**：
   - `shutdown()`方法启动一个平滑的关闭过程，它允许执行完所有已提交的任务，但不接受新任务。
   - 已经提交但尚未开始执行的任务会被执行。
   - 已经开始执行的任务会被允许完成。
   - 在关闭完成后，可以通过调用`awaitTermination()`方法来等待线程池中的所有任务执行完成。
   
2. **shutdownNow()**：
   - `shutdownNow()`方法尝试立即停止所有正在执行的任务，并返回尚未开始执行的任务列表。
   - 它通过中断正在执行的任务线程来实现立即停止。
   - 如果任务对中断响应，它们应该捕捉中断异常并尽快退出。
   - `shutdownNow()`并不保证线程池会立即关闭，但它会尽力停止所有活动。
     总结来说，`shutdown()`是一个平和的关闭过程，允许线程池完成已经提交的任务，而`shutdownNow()`是一个更激烈的关闭尝试，它会尝试立即停止所有任务。在实际使用中，选择哪种关闭方式取决于应用程序的需求和对任务完整性的要求。通常，建议首先尝试使用`shutdown()`进行平滑关闭，如果需要更快地停止线程池，再考虑使用`shutdownNow()`。
   
   
   
   
   
---

   ## 10.  线程池线程数量设置

   - **CPU 密集型任务(N+1)：** 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。
   - **I/O 密集型任务(2N)：** 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。**(IO时间长一点就使用这个，线程数量多设置一点)**



---

