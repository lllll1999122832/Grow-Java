

#  1. CMS三色标记法

CMS为了让GC线程和用户线程一起工作，回收的算法和过程比以前旧的收集器要复杂很多。**究其原因，就是因为GC标记对象的同时，用户线程还在修改对象的引用关系。因此CMS引入了三色标记算法，将对象标记为黑、灰、白三种颜色的对象，并通过「写屏障」技术将用户线程修改的引用关系记录下来，以便在「重新标记」阶段可以修正对象的引用。**
虽然CMS从来没有被JDK当做默认的垃圾收集器，存在很多的缺点，但是它开启了「GC并发收集」的先河，为后面的收集器提供了思路，光凭这一点，就依然值得记录下来。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201108143451681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMDk5ODMz,size_16,color_FFFFFF,t_70#pic_center)

# 2. jvm中变量的存放位置

## 1. **对于局部变量：**

如果是基本类型，会把值和变量名直接存储在栈；

如果是引用类型，比如String s = new String("william");会把其对象存储在堆，而把这个对象的引用（指针）存储在栈。



## 2. **对于成员变量：**

成员变量作为对象的属性，当然是放在**堆**里了。对象在堆里，对象中的内容就是各种字段。
只有方法执行的时候所用到的各种指令参数才会入栈出栈。
类的成员变量在不同对象中各不相同，都有自己的存储空间(成员变量在堆中的对象中)。

**基本类型和引用类型**的成员变量都在**堆的这个对象的空间中**，作为一个整体存储在堆。

而类的方法却是该类的所有对象共享的，只有一套，对象使用方法的时候方法才被压入栈，方法不使用则不占用内存。

**对象实质上就是各种成员变量**，**不包括方法**，因为***\*方法存放在方法区\**\**（方法就是一段被编译的代码，存放在方法区）\****

Java内存模型的主要目标是定义程序中各个变量的访问规则，即在[JVM](https://so.csdn.net/so/search?q=JVM&spm=1001.2101.3001.7020)中将变量存储到内存和从内存中取出变量这样的底层细节。**此处的\**变量(共享变量)\**与Java编程里面的变量有所不同步**，***\*此处的变量包含了实例字段、静态字段和构成数组对象的元素，但不包含局部变量和方法参数，因为后者是线程私有的，不会共享，当然不存在数据竞争问题\****（如果局部变量是一个reference引用类型，它引用的对象在Java堆中可被各个线程共享，但是reference引用本身在Java栈的局部变量表中，是线程私有的）。

---

# 3. OOM怎么排查

排查Java（或基于JVM的语言）应用程序出现Out Of Memory（OOM）异常的过程涉及多个步骤，以下是详细的排查流程：

1. **查看错误日志**：
   - 当Java应用抛出OOM异常时，JVM会生成相关的错误日志，其中包含了内存溢出的具体错误信息和堆栈跟踪，这些信息有助于初步判断是堆空间不足还是元数据区、直接内存等其他区域的内存溢出。

2. **设置JVM参数**：
   - 设置JVM参数以便在发生OOM时生成堆转储（heap dump），例如 `-XX:+HeapDumpOnOutOfMemoryError`，这样当内存溢出发生时，会生成一个堆内存的快照文件，用于后续分析。
   
3. **获取堆转储文件并分析**：
   - 使用内存分析工具如Eclipse Memory Analyzer (MAT)，JProfiler，VisualVM等加载堆转储文件，分析内存占用情况。
   - 查找占用内存最多的对象及其引用关系，确定是否存在内存泄漏（即不再使用的对象仍然被引用导致无法回收）或是正常业务逻辑导致的内存消耗过大。

4. **分析GC日志**：
   - 如果有GC日志，可以通过分析GC活动来了解垃圾收集器的行为，观察是否存在频繁的Full GC、年轻代晋升失败等问题。

5. **代码审查**：
   - 根据堆转储分析结果和日志信息，结合代码审查，查找可能造成内存泄漏的地方，例如静态集合类未清理、长时间存在的大对象、递归或循环引用等。

6. **调整JVM堆大小参数**：
   - 如果不是内存泄漏而是确实需要更多内存，可以适当增加堆空间(-Xmx)和初始堆空间(-Xms)，但需确保不超过物理内存的合理范围，防止操作系统级的内存不足。

7. **优化代码和数据结构**：
   - 对于内存使用合理但总量过大的情况，考虑优化代码实现，减少不必要的对象创建，缩短对象生命周期，或者优化数据结构以更高效地存储和处理数据。

8. **监控与预警**：
   - 在生产环境中实施长期的内存使用监控，设置合理的阈值报警，以便尽早发现潜在的内存问题。

总结起来，排查OOM是一个综合性的过程，需要结合日志分析、内存工具使用、代码审查及系统参数调优等多个手段来有效解决问题。

---

# 4. 关于堆空间

堆空间逻辑上是连续的，物理上是不连续的

---

# 5. JVM参数

- -Xms设置堆的最小空间大小。
- -Xmx设置堆的最大空间大小。
- -XX:NewSize设置新生代最小空间大小。
- -XX:MaxNewSize设置新生代最大空间大小。
- -XX:PermSize设置永久代最小空间大小。
- -XX:MaxPermSize设置永久代最大空间大小。
- -Xss：设置每个线程的栈大小。
- **-XX:NewRatio**：这个参数用来设置老年代和新生代的比例。例如，如果设置为 2，那么新生代和老年代的大小比例将是 1:2。
- **-XX:SurvivorRatio**：这个参数用来设置新生代中 Eden 区和 Survivor 区的比例。例如，如果设置为 8，那么每个 Survivor 区占新生代的 1/8。

---

#  6. JDK 自带定位问题工具

JDK自带了一些非常实用的工具，这些工具可以帮助我们定位和解决Java相关的生产问题。以下是一些最常用的工具：

1. jps：这是一个虚拟机进程查看工具，可以列出正在运行的虚拟机进程信息。
2. jstat：这是虚拟机统计监视工具，可以用来监视虚拟机的运行状态。
3. jinfo：这是一个虚拟机配置信息工具，可以显示关于Java虚拟机的配置信息。
4. jmap：这是虚拟机内存映象工具，可以生成堆转储文件。
5. jstack：这是一个Java堆栈跟踪工具，可以生成Java线程的堆栈跟踪信息。

---

# 7. JVM - OOM可能发生在哪些区域上

| 内存区域   | 是否线程私有 | 是否会发生OOM |
| ---------- | ------------ | ------------- |
| 程序计数器 | 是           | 否            |
| 虚拟机栈   | 是           | 是            |
| 本地方法栈 | 是           | 是            |
| 方法区     | 否           | 是            |
| 直接内存   | 否           | 是            |
| 堆         | 否           | 是            |

---

# 8. 常量池

 Java虚拟机（JVM）中的常量池（Constant Pool）是一个重要的概念，它是Class文件的一部分，用于存储编译期已知的各种字面量和符号引用。常量池可以看作是Class文件中的资源仓库，它为JVM提供了一种快速且方便的方式来访问类中定义的常量。
常量池主要包含以下几类常量：

1. 字面量（Literal）：如字符串字面量、整数字面量、浮点数字面量等。
2. 符号引用（Symbolic References）：主要包括类的全限定名、字段名称和描述符、方法名称和描述符等。
常量池的作用主要表现在以下几个方面：
- **节省空间**：常量池允许相同的字符串字面量在方法区中只保存一份，所有指向该字面量的引用都指向这一份拷贝，从而节省了空间。
- **提高性能**：JVM可以通过常量池中的符号引用直接定位到方法区中的类信息、字段信息和方法信息，提高了访问效率。
- **安全性**：由于在编译时已经确定了所有符号引用，JVM在运行期不会进行动态链接，这样可以减少安全风险。
在Java代码编译成Class文件时，编译器会将所有用到的常量放入常量池中，当类被加载到JVM时，常量池也会被加载到方法区，成为类数据的一部分。在JVM执行字节码时，会频繁地访问常量池，以获取类和接口的相关信息，执行方法调用等。
了解常量池对于理解Java类的加载机制、运行时数据区的结构以及JVM的内存管理都是非常有帮助的。

---

# 9. Java8默认的新生代和老年代的垃圾回收器

JDK 默认垃圾收集器（使用 `java -XX:+PrintCommandLineFlags -version` 命令查看）：

-  JDK 8：Parallel Scavenge（新生代）+ Parallel Old（老年代）
-  JDK 9 ~ JDK20: G1

---

# 10. GC日志是如何查看的？运用到什么工具？

在Java虚拟机（JVM）中，垃圾收集（Garbage Collection，GC）日志是用于记录垃圾收集活动的日志信息。通过分析GC日志，可以了解JVM的内存使用情况、垃圾收集器的性能以及是否存在内存泄漏等问题。要查看GC日志，通常需要配置JVM启动参数以启用日志记录，并使用相应的工具来分析日志。
### 启用GC日志：
要在Java应用程序中启用GC日志，可以在启动JVM时添加以下参数：
```bash
-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:<path-to-gc-log>
```
这些参数的含义如下：
- `-XX:+PrintGCDetails`：打印详细的GC日志信息。
- `-XX:+PrintGCDateStamps`：在GC日志中添加时间戳。
- `-Xloggc:<path-to-gc-log>`：指定GC日志文件的路径。
例如：
```bash
java -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:/var/log/myapp-gc.log -jar myapp.jar
```
### 分析GC日志的工具：

1. **GCViewer**：一个免费的图形工具，用于可视化和分析GC日志。
2. **GCEasy**：一个在线的GC日志分析工具，提供详细的报告和建议。
3. **GCLogViewer**：一个用于分析GC日志的命令行工具。
4. **HPJMeter**：一个用于分析GC日志和JVM性能的工具。
5. **VisualVM**：一个集成了多种JVM分析和监控工具的图形界面工具，可以实时查看GC日志和其他JVM性能数据。
6. **jconsole**：Java自带的监控和管理工具，可以连接到正在运行的JVM并查看GC日志。
7. **MAT (Memory Analyzer Tool)**：用于分析堆转储文件的工具，虽然不是直接分析GC日志，但可以用来诊断内存泄漏和内存使用问题。
要使用这些工具，通常需要将GC日志文件导入到工具中进行分析。例如，GCViewer允许你打开日志文件并展示GC事件的时间线、内存使用情况、GC暂停时间等图表。

### 总结：

启用GC日志并使用适当的工具进行分析，可以帮助开发者理解JVM的内存管理情况，优化应用程序性能，并诊断潜在的内存问题。通过定期审查GC日志，可以确保应用程序的稳定性和响应性。

---

# 11. 动态链接

**动态链接** 主要服务一个方法需要调用其他方法的场景。Class 文件的常量池里保存有大量的符号引用比如方法引用的符号引用。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为 **动态连接** 。

---

